# Generated from /home/chrispy/PycharmProjects/GPS_stimulus_gen/ucbinterm.g4 by ANTLR 4.9
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\13")
        buf.write("x\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16\t")
        buf.write("\16\3\2\6\2\36\n\2\r\2\16\2\37\3\2\3\2\3\3\3\3\6\3&\n")
        buf.write("\3\r\3\16\3\'\3\4\3\4\6\4,\n\4\r\4\16\4-\3\4\3\4\5\4\62")
        buf.write("\n\4\3\5\3\5\3\5\3\6\7\68\n\6\f\6\16\6;\13\6\3\6\3\6\3")
        buf.write("\7\7\7@\n\7\f\7\16\7C\13\7\3\7\3\7\3\b\7\bH\n\b\f\b\16")
        buf.write("\bK\13\b\3\b\3\b\7\bO\n\b\f\b\16\bR\13\b\3\b\3\b\7\bV")
        buf.write("\n\b\f\b\16\bY\13\b\3\b\7\b\\\n\b\f\b\16\b_\13\b\3\b\3")
        buf.write("\b\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\13\3\13\3\f\3\f\3\f\7")
        buf.write("\fo\n\f\f\f\16\fr\13\f\3\r\3\r\3\16\3\16\3\16\3]\2\17")
        buf.write("\2\4\6\b\n\f\16\20\22\24\26\30\32\2\3\4\2\b\b\n\n\2u\2")
        buf.write("\35\3\2\2\2\4#\3\2\2\2\6)\3\2\2\2\b\63\3\2\2\2\n9\3\2")
        buf.write("\2\2\fA\3\2\2\2\16I\3\2\2\2\20b\3\2\2\2\22d\3\2\2\2\24")
        buf.write("i\3\2\2\2\26k\3\2\2\2\30s\3\2\2\2\32u\3\2\2\2\34\36\5")
        buf.write("\4\3\2\35\34\3\2\2\2\36\37\3\2\2\2\37\35\3\2\2\2\37 \3")
        buf.write("\2\2\2 !\3\2\2\2!\"\7\2\2\3\"\3\3\2\2\2#%\5\22\n\2$&\5")
        buf.write("\6\4\2%$\3\2\2\2&\'\3\2\2\2\'%\3\2\2\2\'(\3\2\2\2(\5\3")
        buf.write("\2\2\2)+\5\b\5\2*,\5\n\6\2+*\3\2\2\2,-\3\2\2\2-+\3\2\2")
        buf.write("\2-.\3\2\2\2.\61\3\2\2\2/\62\5\f\7\2\60\62\7\2\2\3\61")
        buf.write("/\3\2\2\2\61\60\3\2\2\2\62\7\3\2\2\2\63\64\5\20\t\2\64")
        buf.write("\65\5\16\b\2\65\t\3\2\2\2\668\7\6\2\2\67\66\3\2\2\28;")
        buf.write("\3\2\2\29\67\3\2\2\29:\3\2\2\2:<\3\2\2\2;9\3\2\2\2<=\5")
        buf.write("\16\b\2=\13\3\2\2\2>@\7\6\2\2?>\3\2\2\2@C\3\2\2\2A?\3")
        buf.write("\2\2\2AB\3\2\2\2BD\3\2\2\2CA\3\2\2\2DE\7\13\2\2E\r\3\2")
        buf.write("\2\2FH\7\6\2\2GF\3\2\2\2HK\3\2\2\2IG\3\2\2\2IJ\3\2\2\2")
        buf.write("JL\3\2\2\2KI\3\2\2\2LP\5\24\13\2MO\7\6\2\2NM\3\2\2\2O")
        buf.write("R\3\2\2\2PN\3\2\2\2PQ\3\2\2\2QS\3\2\2\2RP\3\2\2\2SW\5")
        buf.write("\26\f\2TV\7\6\2\2UT\3\2\2\2VY\3\2\2\2WU\3\2\2\2WX\3\2")
        buf.write("\2\2X]\3\2\2\2YW\3\2\2\2Z\\\13\2\2\2[Z\3\2\2\2\\_\3\2")
        buf.write("\2\2]^\3\2\2\2][\3\2\2\2^`\3\2\2\2_]\3\2\2\2`a\7\13\2")
        buf.write("\2a\17\3\2\2\2bc\7\7\2\2c\21\3\2\2\2de\7\3\2\2ef\7\n\2")
        buf.write("\2fg\7\4\2\2gh\7\13\2\2h\23\3\2\2\2ij\7\t\2\2j\25\3\2")
        buf.write("\2\2kp\5\32\16\2lm\7\5\2\2mo\5\32\16\2nl\3\2\2\2or\3\2")
        buf.write("\2\2pn\3\2\2\2pq\3\2\2\2q\27\3\2\2\2rp\3\2\2\2st\t\2\2")
        buf.write("\2t\31\3\2\2\2uv\7\b\2\2v\33\3\2\2\2\r\37\'-\619AIPW]")
        buf.write("p")
        return buf.getvalue()


class ucbintermParser ( Parser ):

    grammarFileName = "ucbinterm.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'<<< New Epoch '", "' >>>'", "' '" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "WHITE", "TIME", "HEX_VAL", "INDEX", "TEXT", "NEWLINE" ]

    RULE_data_stream = 0
    RULE_epoch = 1
    RULE_msg = 2
    RULE_msg_hdr = 3
    RULE_msg_row = 4
    RULE_msg_end = 5
    RULE_msg_contents = 6
    RULE_timestamp = 7
    RULE_ep_stamp = 8
    RULE_line_no = 9
    RULE_msg_payload = 10
    RULE_msg_text = 11
    RULE_hex_byte = 12

    ruleNames =  [ "data_stream", "epoch", "msg", "msg_hdr", "msg_row", 
                   "msg_end", "msg_contents", "timestamp", "ep_stamp", "line_no", 
                   "msg_payload", "msg_text", "hex_byte" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    WHITE=4
    TIME=5
    HEX_VAL=6
    INDEX=7
    TEXT=8
    NEWLINE=9

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Data_streamContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ucbintermParser.EOF, 0)

        def epoch(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ucbintermParser.EpochContext)
            else:
                return self.getTypedRuleContext(ucbintermParser.EpochContext,i)


        def getRuleIndex(self):
            return ucbintermParser.RULE_data_stream

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_stream" ):
                listener.enterData_stream(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_stream" ):
                listener.exitData_stream(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitData_stream" ):
                return visitor.visitData_stream(self)
            else:
                return visitor.visitChildren(self)




    def data_stream(self):

        localctx = ucbintermParser.Data_streamContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_data_stream)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 27 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 26
                self.epoch()
                self.state = 29 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==ucbintermParser.T__0):
                    break

            self.state = 31
            self.match(ucbintermParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class EpochContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ep_stamp(self):
            return self.getTypedRuleContext(ucbintermParser.Ep_stampContext,0)


        def msg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ucbintermParser.MsgContext)
            else:
                return self.getTypedRuleContext(ucbintermParser.MsgContext,i)


        def getRuleIndex(self):
            return ucbintermParser.RULE_epoch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEpoch" ):
                listener.enterEpoch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEpoch" ):
                listener.exitEpoch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEpoch" ):
                return visitor.visitEpoch(self)
            else:
                return visitor.visitChildren(self)




    def epoch(self):

        localctx = ucbintermParser.EpochContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_epoch)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self.ep_stamp()
            self.state = 35 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 34
                self.msg()
                self.state = 37 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==ucbintermParser.TIME):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MsgContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def msg_hdr(self):
            return self.getTypedRuleContext(ucbintermParser.Msg_hdrContext,0)


        def msg_end(self):
            return self.getTypedRuleContext(ucbintermParser.Msg_endContext,0)


        def EOF(self):
            return self.getToken(ucbintermParser.EOF, 0)

        def msg_row(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ucbintermParser.Msg_rowContext)
            else:
                return self.getTypedRuleContext(ucbintermParser.Msg_rowContext,i)


        def getRuleIndex(self):
            return ucbintermParser.RULE_msg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMsg" ):
                listener.enterMsg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMsg" ):
                listener.exitMsg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMsg" ):
                return visitor.visitMsg(self)
            else:
                return visitor.visitChildren(self)




    def msg(self):

        localctx = ucbintermParser.MsgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_msg)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 39
            self.msg_hdr()
            self.state = 41 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 40
                    self.msg_row()

                else:
                    raise NoViableAltException(self)
                self.state = 43 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

            self.state = 47
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ucbintermParser.WHITE, ucbintermParser.NEWLINE]:
                self.state = 45
                self.msg_end()
                pass
            elif token in [ucbintermParser.EOF]:
                self.state = 46
                self.match(ucbintermParser.EOF)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Msg_hdrContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def timestamp(self):
            return self.getTypedRuleContext(ucbintermParser.TimestampContext,0)


        def msg_contents(self):
            return self.getTypedRuleContext(ucbintermParser.Msg_contentsContext,0)


        def getRuleIndex(self):
            return ucbintermParser.RULE_msg_hdr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMsg_hdr" ):
                listener.enterMsg_hdr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMsg_hdr" ):
                listener.exitMsg_hdr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMsg_hdr" ):
                return visitor.visitMsg_hdr(self)
            else:
                return visitor.visitChildren(self)




    def msg_hdr(self):

        localctx = ucbintermParser.Msg_hdrContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_msg_hdr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            self.timestamp()
            self.state = 50
            self.msg_contents()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Msg_rowContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def msg_contents(self):
            return self.getTypedRuleContext(ucbintermParser.Msg_contentsContext,0)


        def WHITE(self, i:int=None):
            if i is None:
                return self.getTokens(ucbintermParser.WHITE)
            else:
                return self.getToken(ucbintermParser.WHITE, i)

        def getRuleIndex(self):
            return ucbintermParser.RULE_msg_row

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMsg_row" ):
                listener.enterMsg_row(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMsg_row" ):
                listener.exitMsg_row(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMsg_row" ):
                return visitor.visitMsg_row(self)
            else:
                return visitor.visitChildren(self)




    def msg_row(self):

        localctx = ucbintermParser.Msg_rowContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_msg_row)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 55
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 52
                    self.match(ucbintermParser.WHITE) 
                self.state = 57
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

            self.state = 58
            self.msg_contents()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Msg_endContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEWLINE(self):
            return self.getToken(ucbintermParser.NEWLINE, 0)

        def WHITE(self, i:int=None):
            if i is None:
                return self.getTokens(ucbintermParser.WHITE)
            else:
                return self.getToken(ucbintermParser.WHITE, i)

        def getRuleIndex(self):
            return ucbintermParser.RULE_msg_end

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMsg_end" ):
                listener.enterMsg_end(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMsg_end" ):
                listener.exitMsg_end(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMsg_end" ):
                return visitor.visitMsg_end(self)
            else:
                return visitor.visitChildren(self)




    def msg_end(self):

        localctx = ucbintermParser.Msg_endContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_msg_end)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ucbintermParser.WHITE:
                self.state = 60
                self.match(ucbintermParser.WHITE)
                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 66
            self.match(ucbintermParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Msg_contentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def line_no(self):
            return self.getTypedRuleContext(ucbintermParser.Line_noContext,0)


        def msg_payload(self):
            return self.getTypedRuleContext(ucbintermParser.Msg_payloadContext,0)


        def NEWLINE(self):
            return self.getToken(ucbintermParser.NEWLINE, 0)

        def WHITE(self, i:int=None):
            if i is None:
                return self.getTokens(ucbintermParser.WHITE)
            else:
                return self.getToken(ucbintermParser.WHITE, i)

        def getRuleIndex(self):
            return ucbintermParser.RULE_msg_contents

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMsg_contents" ):
                listener.enterMsg_contents(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMsg_contents" ):
                listener.exitMsg_contents(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMsg_contents" ):
                return visitor.visitMsg_contents(self)
            else:
                return visitor.visitChildren(self)




    def msg_contents(self):

        localctx = ucbintermParser.Msg_contentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_msg_contents)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 71
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ucbintermParser.WHITE:
                self.state = 68
                self.match(ucbintermParser.WHITE)
                self.state = 73
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 74
            self.line_no()
            self.state = 78
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==ucbintermParser.WHITE:
                self.state = 75
                self.match(ucbintermParser.WHITE)
                self.state = 80
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 81
            self.msg_payload()
            self.state = 85
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 82
                    self.match(ucbintermParser.WHITE) 
                self.state = 87
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

            self.state = 91
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1+1:
                    self.state = 88
                    self.matchWildcard() 
                self.state = 93
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

            self.state = 94
            self.match(ucbintermParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TimestampContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TIME(self):
            return self.getToken(ucbintermParser.TIME, 0)

        def getRuleIndex(self):
            return ucbintermParser.RULE_timestamp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTimestamp" ):
                listener.enterTimestamp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTimestamp" ):
                listener.exitTimestamp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTimestamp" ):
                return visitor.visitTimestamp(self)
            else:
                return visitor.visitChildren(self)




    def timestamp(self):

        localctx = ucbintermParser.TimestampContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_timestamp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.match(ucbintermParser.TIME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ep_stampContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self):
            return self.getToken(ucbintermParser.TEXT, 0)

        def NEWLINE(self):
            return self.getToken(ucbintermParser.NEWLINE, 0)

        def getRuleIndex(self):
            return ucbintermParser.RULE_ep_stamp

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEp_stamp" ):
                listener.enterEp_stamp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEp_stamp" ):
                listener.exitEp_stamp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitEp_stamp" ):
                return visitor.visitEp_stamp(self)
            else:
                return visitor.visitChildren(self)




    def ep_stamp(self):

        localctx = ucbintermParser.Ep_stampContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ep_stamp)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            self.match(ucbintermParser.T__0)
            self.state = 99
            self.match(ucbintermParser.TEXT)
            self.state = 100
            self.match(ucbintermParser.T__1)
            self.state = 101
            self.match(ucbintermParser.NEWLINE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Line_noContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDEX(self):
            return self.getToken(ucbintermParser.INDEX, 0)

        def getRuleIndex(self):
            return ucbintermParser.RULE_line_no

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLine_no" ):
                listener.enterLine_no(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLine_no" ):
                listener.exitLine_no(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLine_no" ):
                return visitor.visitLine_no(self)
            else:
                return visitor.visitChildren(self)




    def line_no(self):

        localctx = ucbintermParser.Line_noContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_line_no)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 103
            self.match(ucbintermParser.INDEX)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Msg_payloadContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def hex_byte(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(ucbintermParser.Hex_byteContext)
            else:
                return self.getTypedRuleContext(ucbintermParser.Hex_byteContext,i)


        def getRuleIndex(self):
            return ucbintermParser.RULE_msg_payload

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMsg_payload" ):
                listener.enterMsg_payload(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMsg_payload" ):
                listener.exitMsg_payload(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMsg_payload" ):
                return visitor.visitMsg_payload(self)
            else:
                return visitor.visitChildren(self)




    def msg_payload(self):

        localctx = ucbintermParser.Msg_payloadContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_msg_payload)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 105
            self.hex_byte()
            self.state = 110
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,10,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 106
                    self.match(ucbintermParser.T__2)
                    self.state = 107
                    self.hex_byte() 
                self.state = 112
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,10,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Msg_textContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self):
            return self.getToken(ucbintermParser.TEXT, 0)

        def HEX_VAL(self):
            return self.getToken(ucbintermParser.HEX_VAL, 0)

        def getRuleIndex(self):
            return ucbintermParser.RULE_msg_text

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMsg_text" ):
                listener.enterMsg_text(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMsg_text" ):
                listener.exitMsg_text(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMsg_text" ):
                return visitor.visitMsg_text(self)
            else:
                return visitor.visitChildren(self)




    def msg_text(self):

        localctx = ucbintermParser.Msg_textContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_msg_text)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            _la = self._input.LA(1)
            if not(_la==ucbintermParser.HEX_VAL or _la==ucbintermParser.TEXT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Hex_byteContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HEX_VAL(self):
            return self.getToken(ucbintermParser.HEX_VAL, 0)

        def getRuleIndex(self):
            return ucbintermParser.RULE_hex_byte

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHex_byte" ):
                listener.enterHex_byte(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHex_byte" ):
                listener.exitHex_byte(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitHex_byte" ):
                return visitor.visitHex_byte(self)
            else:
                return visitor.visitChildren(self)




    def hex_byte(self):

        localctx = ucbintermParser.Hex_byteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_hex_byte)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 115
            self.match(ucbintermParser.HEX_VAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





